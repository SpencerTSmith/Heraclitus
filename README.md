# Fix Soon:
- Better render pass state tracking... maybe push and pop GL state procs? Since we are caching them we'll be able to check those calls and not do em if not necessary
- Split shadow-casting point lights and non-shadow-casting lights... this can just be a bool... but should be separate arrays in the global frame uniform
- Improve immediate rendering batching
    - Look for already started batches that match state and append... or...
    - Sort batches by state change when flushing
    - Maybe not... this might be the job of higher level layers
        - The UI will want its draw commands submitted in a particular order... any batch sorting may override that
        - So far don't think it matters for 3d debug visuals
- Sort of just normalizing vectors everywhere, probably redundantly... profile and find out if this is significant enough to fix
- More AZDO:
    - Multi-draw indirect
        - Try with just doing so for models with multiple mesh primitives... looks simple to do before doing next step
    - Put all normal geometry into one vertex buffer, both for locality reasons and to allow for big multi-draw-indirect
- Cache calculated world AABB's, have dirty flag if world transform has changed and need to recalc
- Switch fully to PBR lighting model

# Complete:
- Cool GLSL metaprogramming
    - Generate GLSL code that needs to match up with host code (uniform struct definitions, buffer binding locations, etc) so less tedious and only need to edit one spot
- AABB basic collision detection and response
- Quake-like player-movement (Bunny-hopping, wall-running, strafe-jumping)
- AZDO OpenGL techniques:
    - Frames in flight sync, triple-up persistently mapped buffers
    - Bindless textures for model materials (Still doing traditional binding api for less commonly bound textures like shadow maps, skybox, etc)
- Immediate vertex rendering system, will batch calls and only submit them once we have synced the frame
    - AABB, sphere, and vector debug visuals
    - Text rendering
- Point light shadow mapping
    - Cube map array render target... pretty efficient storage, and can minimize draw calls with instanced rendering (6 instances for each map side)
    - Culls entities if not intersecting light radius sphere
- Sun shadow mapping
- Full blinn-phong shading model
- Menu (press ESC)
- Zoom (scroll wheel)
- GLTF model loading (works as far as I can tell, obviously not even close to all the features)
